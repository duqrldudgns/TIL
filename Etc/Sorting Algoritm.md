# 정렬 알고리즘


---

## 시간 복잡도의 빠르기

### O(1) > O(logN) > O(N) > O(NlogN) > O(N^2) > O(2^N) > O(N!)



---

## 시간 & 공간 복잡도

![Untitled](https://media.vlpt.us/images/jaeyunn_15/post/ff10da68-72c8-465e-9da8-9260b26db9a9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-03-07%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.32.57.png)


---

## 장단점

![Untitled](https://media.vlpt.us/images/jaeyunn_15/post/d83b3d81-6c55-4996-a2eb-d2e635a98cb6/image.png)

---

## 선택 정렬

> 해당 인덱스에 맞는 값을 선택하여 해당 위치로 이동시키는 정렬
> 

### 장점

- 구현이 쉬움
- **정렬을 위한 비교 횟수가 많지만 실제 교환 횟수는 적음**

### 단점

- 최악, 최선 모두 **O(N^2)의 시간복잡도로 비효율적**

### 유용한 곳

- ❗**정렬을 위한 비교 횟수가 많지만 실제 교환 횟수는 적기에** 많은 교환이 일어나야 하는 자료 상태에서 효율적

---

## 버블 정렬

> 인접한 두 값 비교하여 정렬
> 

### 장점

- 구현이 쉬움
- 코드가 직관적

### 단점

- 최악, 최선 모두 **O(N^2)의 시간복잡도로 비효율적**

### 유용한 곳

- **이미 정렬된 데이터를 정렬** 시에 가장 빠름
    - **반대로 역순 배열은 가장 느림**

---

## 삽입 정렬

> 정렬된 집합에 새로운 원소의 적절한 위치를 찾아 삽입하는 정렬 방식
> 

### 장점

- ❗최선의 경우, O(N)이라는 엄청난 효율성을 가짐
- 다른 정렬 알고리즘의 일부로도 쓰임

### 단점

- 최악의 경우, O(N^2)이라는 시간 복잡도를 가짐
- **데이터의 상태, 크기에 따라 성능 편차가 심함**

### 유용한 곳

- ❗**이미 정렬된 경우, 아주 최고의 정렬 알고리즘(**탐색을 제외한 오버헤드가 매우 적기에**)**
- 배열이 작을수록 효율적

---

## 병합 정렬(Merge Sort)

> 각 배열을 크기가 1이 될 때까지 분할 후 다시 정렬하면서 합쳐가는 정렬 방식 - 분할정복 방식
> 

### 장점

- **항상 O(NlogN)이라는 시간 복잡도**
    - 피벗 설정 할 필요 없이 무조건 절반으로 분할하기에 피벗에 따라 성능이 안 좋을 일은 없음
- 퀵 정렬과 비슷하게 원본 배열을 분할하면서 정렬하는 방법으로 분할 과정에서 logN만큼 시간이 걸림. 최종적으로는 NlogN

### 단점

- ❗추가 메모리가 필요하다는 큰 단점
    - 퀵 정렬보다 당연 좋다고 생각하겠지만 임시 배열에 원본 맵을 계속해서 옮겨주면서 정렬하는 방법이기 때문

### 유용한 곳

- **순차적인 비교로 정렬하기에 LinkedList의 정렬에 사용하면 효율적**
- **크기가 큰 레코드 정렬 시** 매우 효율적!

---

## 퀵 정렬

> 피벗을 정한 후, 피벗보다 작으면 왼쪽, 크면 오른쪽으로 정렬하고 이 과정을 반복하는 방식
> 

### 장점

- 기준 값(피벗)에 의한 분할을 통해 구현하는 정렬법으로써, **분할 과정에서 logN,** **전체적으로 NlogN의 시간 복잡도**

### 단점

- ❗**최악의 경우 O(N^2)의 시간 복잡도**
    - 기준 값(피벗)이 맨 앞 또는 뒤 일 경우
- **불안정 정렬**

### 유용한 곳

- 순차 접근이 아닌 **임의 접근이기에 LinkedList를 퀵 정렬에 사용하면 비효율적**

**🖐 추가적인 메모리 할당할 수 없는 경우, 데이터가 최악으로 있다면 병합 vs 퀵 중에 뭘 써야 할까?**

👉 데이터가 최악인 것만 본다면 퀵 보다 병합 정렬이 훨씬 빠르지만 추가 메모리 할당이 없다면 병합 정렬은 사용 불가이기에 퀵을 써야한다.

---

## 힙 정렬

> " 최대 힙을 만들고 루트 노드 던지고 마지막 노드를 루트 노드 위치에 넣고 다시 최대 힙 만들기를 반복"
> 

### 장점

- 추가 메모리가 필요하지 않음
- 항상 O(NlogN)이라는 시간 복잡도로 갖는 다른 O(NlogN)정렬법 중 가장 효율적

### 단점

- ❗데이터 상태에 따라 다른 O(NlogN)정렬법에 비해 느린편.
- **불안정 정렬**

### 유용한 곳

- **가장 크거나 가장 작은 값을 구할 때**
- **최대 K만큼 떨어진 요소들을 구할 때** (삽입 정렬보다 더욱 개선된 효과)

---

## 쉘 정렬

> 
> 

### 장점

- 삽입정렬의 단점을 보완해서 만든 정렬법으로 더욱 뛰어난 성능

### 단점

- 일정한 간격에 따라서 배열을 바라봐야 하는데 이 간격을 잘못 설정하면 성능 하락

---

## 기수 정렬

> 
> 

### 장점

- ❗O(N)이라는 시간 복잡도
- O(NlogN)을 깰 수 있는 방법은 없다고 알려져 있는데, 그 방법을 깨는 유일한 방법

### 단점

- 버킷이라는 추가적인 메모리 할당 때문에 메모리 소비가 심함
- 데이터 타입이 일정한 경우에만 가능 (양수, 음수, 실수, 정수 등)
- 이처럼 구현을 위한 조건이 많이 붙음


---

[모든 정렬의 동작 과정과 속도 비교 가능한 사이트](https://www.toptal.com/developers/sorting-algorithms)

[참조 사이트](https://velog.io/@jaeyunn_15/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%81-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B9%84%EA%B5%90)
